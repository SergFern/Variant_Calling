#!/usr/bin/env nextflow

if(params.genome != "GRCh37" && params.genome != "GRCh38"){

custom_reference = file("${params.genome}") 
prefixRef = custom_reference.name.take(custom_reference.name.lastIndexOf('.'))

}

def ploidy = params.ploidy != 'no' || params.ploidy == 'yes' && params.ploidy.getClass() == java.lang.Integer ? "--ploidy ${params.ploidy} ":''
def reference = params.genome != "GRCh37" && params.genome != "GRCh38" ? "${params.working_dir}/${params.indir}/custom_reference/${prefixRef}.fasta": params.indexRef

if(!params.GVCFmode){

    def samplePrefix = params.common_id != '*' ? "${params.common_id}":""

      Channel
        .fromFilePairs("${params.outdir}/alignment/${samplePrefix}*{${bam_name},${bam_name}.bai}", size : 2, type: "any")
        .set{ch_variant_calling}
  
    process Variant_Calling_single {
      tag "Variant calling using selected Variant Caller (GATK, freebayes, varscan)"
      //publishDir "$params.outdir/raw_variant_calling_files", mode: 'copy'

      //def reference = params.genome != "GRCh37" && params.genome != "GRCh38" ? "${params.working_dir}/${params.indir}/reference/${prefixRef}.fasta": params.indexRef

      input:
      // Imma need to generate a tsv with all bam files paths listed so I can feed all of them to freebayes and other variant callers together
        set sampleId, file(bam_file),file(bai_file) from ch_variant_calling //.combine(ch_variant_calling2)

      output:
        set sampleId, file('*vcf') into ch_vcf
      //reference = file(params.seqRef)

      script:
        /*
        println("${bam_file[0]}")
        println("${bam_file[1]}")
        */

        if(params.vc == 'gatk'){

        """
        gatk HaplotypeCaller --native-pair-hmm-threads ${params.threads} ${params.rmDups_GATK} ${region_interval} -I ${bam_file[0]} -O ${sampleId}.${params.vc}.vcf -R ${reference} ${params.vcOpts}
        """
        }else if(params.vc == 'freebayes'){

        """
        freebayes ${ploidy} -f ${reference} ${bam_file[0]} > ${sampleId}.${params.vc}.vcf
        """
        }else if(params.vc == 'varscan'){
        """
        samtools mpileup -B -f ${reference} ${bam_file[0]} | varscan mpileup2cns --variants --output-vcf 1 > ${sampleId}.${params.vc}.vcf
        
        """
        }
      }

    }else{

      // Gather all alignment files from the same experiment to process together

      def samplePrefix = params.common_id != '*' ? "${params.common_id}":""
      def bam_name = params.dbSNP == 'NO_FILE' ? "sort.bam":"bqsr.bam"

      if(params.common_id == '*'){
          Channel
            .fromFilePairs("${params.outdir}/alignment/${samplePrefix}*{${bam_name},${bam_name}.bai}", size : 2, type: "any", checkIfExists: true)
            .map{it -> [it[0][0,1], it[1]]}
            .groupTuple()
            .set{ch_variant_calling}

      }else{
          Channel
            .fromFilePairs("${params.outdir}/alignment/${samplePrefix}*{${bam_name},${bam_name}.bai}", size : 2, type: "any")
            .map{it -> [params.common_id, it[1]]}
            .groupTuple()
            .set{ch_variant_calling}

      }

      process Variant_Calling_batch {
        tag "Variant calling using selected Variant Caller (GATK, freebayes, varscan)"
        //publishDir "$params.outdir/raw_variant_calling_files", mode: 'copy'

        //def reference = params.genome != "GRCh37" && params.genome != "GRCh38" ? "${params.working_dir}/${params.indir}/reference/${prefixRef}.fasta": params.indexRef

        input:
          set expId, val(data) from ch_variant_calling //.combine(ch_variant_calling2)

        output:
          set expId, file('*vcf') into ch_vcf
        //reference = file(params.seqRef)

        script:

          String bams = data.flatten().collate(1,2).flatten().join(" ")

          if(params.vc == 'gatk'){

            println("gatk right now is incompatible with GVCFmode")

          }else if(params.vc == 'freebayes'){

            def GVCF = "--gvcf"
          """
          freebayes ${ploidy} --min-alternate-fraction ${params.min_alt_fraction} ${GVCF} -f ${reference} ${bams} > ${expId}.${params.vc}.vcf
          """
          }else if(params.vc == 'varscan'){

          println("varscan right now is incompatible with GVCFmode")

          }
        }


    }

  process VCF_indexing {
    tag "Indexes vcf files generated by Variant_Calling"

    publishDir "$params.outdir/raw_variant_calling_files", mode: 'copy'

    input:
      set sampleId, file(vcf_file) from ch_vcf
    output:
      set sampleId, file("${vcf_file[0]}"), file('*.vcf.idx')

    script:
    """
    gatk IndexFeatureFile --input ${vcf_file[0]}
    """
  }